<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ã‚ªã‚»ãƒ­ - Othello Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', 'Helvetica', 'Hiragino Sans', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 1200px;
    }

    .panel {
      background: white;
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }

    .game-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 25px;
    }

    .side-panel {
      width: 320px;
      display: flex;
      flex-direction: column;
      gap: 25px;
    }

    h1 {
      font-size: 3rem;
      color: #1e293b;
      text-align: center;
      margin: 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }

    .status {
      width: 100%;
      padding: 25px;
      background: linear-gradient(135deg, #1e293b, #334155);
      color: white;
      text-align: center;
      font-size: 1.8rem;
      font-weight: bold;
      border-radius: 15px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.3s;
    }

    .status.white-turn {
      background: linear-gradient(135deg, #f8fafc, #e2e8f0);
      color: #1e293b;
    }

    .status.game-over {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .score-board {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      width: 100%;
    }

    .score-item {
      flex: 1;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      transition: all 0.3s;
    }

    .score-item.black {
      background: linear-gradient(135deg, #1e293b, #334155);
      color: white;
    }

    .score-item.white {
      background: linear-gradient(135deg, #f8fafc, #e2e8f0);
      color: #1e293b;
      border: 3px solid #cbd5e1;
    }

    .score-item.active {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }

    .score-label {
      font-size: 1.1rem;
      margin-bottom: 10px;
      opacity: 0.9;
    }

    .score-value {
      font-size: 3rem;
      font-weight: bold;
    }

    .board-wrapper {
      background: linear-gradient(135deg, #059669, #047857);
      padding: 25px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, 70px);
      grid-template-rows: repeat(8, 70px);
      gap: 2px;
      background: #1e293b;
      border: 4px solid #1e293b;
      border-radius: 8px;
      overflow: hidden;
    }

    .cell {
      background: #10b981;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
    }

    .cell:hover {
      background: #34d399;
    }

    .cell.can-place {
      background: #6ee7b7;
      cursor: pointer;
    }

    .cell.can-place::after {
      content: '';
      width: 25px;
      height: 25px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      position: absolute;
      animation: hint 1s infinite;
    }

    @keyframes hint {
      0%, 100% { transform: scale(1); opacity: 0.4; }
      50% { transform: scale(1.3); opacity: 0.7; }
    }

    .piece {
      width: 55px;
      height: 55px;
      border-radius: 50%;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      transition: all 0.3s;
      animation: place 0.3s ease-out;
    }

    @keyframes place {
      0% { transform: scale(0) rotateY(0deg); }
      50% { transform: scale(1.2) rotateY(180deg); }
      100% { transform: scale(1) rotateY(360deg); }
    }

    .piece.black {
      background: radial-gradient(circle at 30% 30%, #4b5563, #1e293b);
      border: 2px solid #0f172a;
    }

    .piece.white {
      background: radial-gradient(circle at 30% 30%, #ffffff, #e2e8f0);
      border: 2px solid #cbd5e1;
    }

    .buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .btn {
      padding: 18px 25px;
      border: none;
      border-radius: 12px;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      color: white;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .btn:active {
      transform: translateY(-1px);
    }

    .btn-primary {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
    }

    .btn-secondary {
      background: linear-gradient(135deg, #64748b, #475569);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444, #dc2626);
    }

    .info-box {
      background: #f8fafc;
      padding: 20px;
      border-radius: 12px;
      border: 2px solid #e2e8f0;
    }

    .info-box h2 {
      color: #1e293b;
      margin-bottom: 15px;
      font-size: 1.4rem;
      border-bottom: 2px solid #cbd5e1;
      padding-bottom: 10px;
    }

    .rules {
      font-size: 1rem;
      line-height: 1.8;
      color: #475569;
    }

    .rules li {
      margin: 10px 0;
      padding-left: 5px;
    }

    .history {
      max-height: 350px;
      overflow-y: auto;
      background: white;
      padding: 15px;
      border-radius: 8px;
      font-size: 0.95rem;
    }

    .history-item {
      padding: 12px;
      margin: 8px 0;
      background: #f8fafc;
      border-radius: 8px;
      border-left: 4px solid #1e293b;
    }

    .history-item.white {
      border-left-color: #94a3b8;
    }

    .hint-box {
      background: #fef3c7;
      border: 2px solid #fbbf24;
      padding: 15px;
      border-radius: 10px;
      color: #92400e;
      font-size: 0.95rem;
      line-height: 1.6;
    }

    @media (max-width: 1024px) {
      .board {
        grid-template-columns: repeat(8, 50px);
        grid-template-rows: repeat(8, 50px);
      }

      .piece {
        width: 40px;
        height: 40px;
      }

      .cell.can-place::after {
        width: 18px;
        height: 18px;
      }
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .side-panel {
        width: 100%;
      }

      .board {
        grid-template-columns: repeat(8, 45px);
        grid-template-rows: repeat(8, 45px);
      }

      .piece {
        width: 35px;
        height: 35px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- å·¦ãƒ‘ãƒãƒ« -->
    <div class="side-panel panel">
      <div class="info-box">
        <h2>ğŸ® ã‚²ãƒ¼ãƒ æ“ä½œ</h2>
        <div class="buttons">
          <button class="btn btn-primary" onclick="newGame()">æ–°è¦ã‚²ãƒ¼ãƒ </button>
          <button class="btn btn-secondary" onclick="undoMove()">1æ‰‹æˆ»ã™</button>
          <button class="btn btn-danger" onclick="pass()">ãƒ‘ã‚¹</button>
        </div>
      </div>

      <div class="info-box">
        <h2>ğŸ“– ãƒ«ãƒ¼ãƒ«</h2>
        <ul class="rules">
          <li>ğŸ’¡ ç›¸æ‰‹ã®çŸ³ã‚’æŒŸã‚“ã§ã²ã£ãã‚Šè¿”ã™</li>
          <li>ğŸ¯ ç·‘ã®ãƒã‚¹ã«çŸ³ã‚’ç½®ã‘ã‚‹</li>
          <li>â­ï¸ ç½®ã‘ãªã„æ™‚ã¯è‡ªå‹•ãƒ‘ã‚¹</li>
          <li>ğŸ† ç›¤é¢ãŒåŸ‹ã¾ã£ãŸã‚‰çµ‚äº†</li>
          <li>ğŸ‘‘ çŸ³ãŒå¤šã„æ–¹ãŒå‹ã¡</li>
        </ul>
      </div>

      <div class="hint-box">
        ğŸ’¡ <strong>ãƒ’ãƒ³ãƒˆï¼š</strong><br>
        è§’ï¼ˆå››éš…ï¼‰ã‚’å–ã‚‹ã¨æœ‰åˆ©ï¼<br>
        ç›¸æ‰‹ã«è§’ã‚’å–ã‚‰ã‚Œãªã„ã‚ˆã†æ³¨æ„ã—ã‚ˆã†ã€‚
      </div>
    </div>

    <!-- ä¸­å¤®ãƒ‘ãƒãƒ« -->
    <div class="game-panel panel">
      <h1>âš«âšª ã‚ªã‚»ãƒ­</h1>
      
      <div class="status" id="status">âš« é»’ã®ç•ª</div>

      <div class="score-board">
        <div class="score-item black active" id="blackScore">
          <div class="score-label">âš« é»’</div>
          <div class="score-value">2</div>
        </div>
        <div class="score-item white" id="whiteScore">
          <div class="score-label">âšª ç™½</div>
          <div class="score-value">2</div>
        </div>
      </div>

      <div class="board-wrapper">
        <div class="board" id="board"></div>
      </div>
    </div>

    <!-- å³ãƒ‘ãƒãƒ« -->
    <div class="side-panel panel">
      <div class="info-box">
        <h2>ğŸ“‹ å±¥æ­´</h2>
        <div class="history" id="history">
          <p style="text-align: center; color: #94a3b8;">ã‚²ãƒ¼ãƒ ãŒé€²ã‚€ã¨è¡¨ç¤ºã•ã‚Œã¾ã™</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let game = {
      board: Array(8).fill(null).map(() => Array(8).fill(null)),
      turn: 'black',
      history: [],
      gameOver: false,
      passCount: 0
    };

    // æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆ8æ–¹å‘ï¼‰
    const DIRECTIONS = [
      [-1, -1], [0, -1], [1, -1],
      [-1, 0],           [1, 0],
      [-1, 1],  [0, 1],  [1, 1]
    ];

    // åˆæœŸåŒ–
    function init() {
      game.board = Array(8).fill(null).map(() => Array(8).fill(null));
      game.board[3][3] = 'white';
      game.board[3][4] = 'black';
      game.board[4][3] = 'black';
      game.board[4][4] = 'white';
      game.turn = 'black';
      game.history = [];
      game.gameOver = false;
      game.passCount = 0;
    }

    // æç”»
    function render() {
      const board = document.getElementById('board');
      board.innerHTML = '';

      const validMoves = getValidMoves(game.turn);

      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.onclick = () => placePiece(x, y);

          if (game.board[y][x]) {
            const piece = document.createElement('div');
            piece.className = `piece ${game.board[y][x]}`;
            cell.appendChild(piece);
          } else if (validMoves.some(([mx, my]) => mx === x && my === y)) {
            cell.classList.add('can-place');
          }

          board.appendChild(cell);
        }
      }

      updateScore();
      updateStatus();
    }

    // æœ‰åŠ¹ãªæ‰‹ã‚’å–å¾—
    function getValidMoves(player) {
      const moves = [];

      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          if (game.board[y][x]) continue;
          if (canPlace(x, y, player)) {
            moves.push([x, y]);
          }
        }
      }

      return moves;
    }

    // çŸ³ã‚’ç½®ã‘ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    function canPlace(x, y, player) {
      if (game.board[y][x]) return false;

      const opponent = player === 'black' ? 'white' : 'black';

      for (const [dx, dy] of DIRECTIONS) {
        let nx = x + dx;
        let ny = y + dy;
        let found = false;

        while (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
          if (!game.board[ny][nx]) break;
          if (game.board[ny][nx] === opponent) {
            found = true;
            nx += dx;
            ny += dy;
          } else if (game.board[ny][nx] === player) {
            if (found) return true;
            break;
          }
        }
      }

      return false;
    }

    // çŸ³ã‚’ç½®ã
    function placePiece(x, y) {
      if (game.gameOver) return;
      if (!canPlace(x, y, game.turn)) return;

      game.board[y][x] = game.turn;
      flipPieces(x, y, game.turn);

      addHistory(x, y);
      game.passCount = 0;
      nextTurn();
    }

    // çŸ³ã‚’ã²ã£ãã‚Šè¿”ã™
    function flipPieces(x, y, player) {
      const opponent = player === 'black' ? 'white' : 'black';
      const toFlip = [];

      for (const [dx, dy] of DIRECTIONS) {
        const line = [];
        let nx = x + dx;
        let ny = y + dy;

        while (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
          if (!game.board[ny][nx]) break;
          if (game.board[ny][nx] === opponent) {
            line.push([nx, ny]);
            nx += dx;
            ny += dy;
          } else if (game.board[ny][nx] === player) {
            toFlip.push(...line);
            break;
          } else {
            break;
          }
        }
      }

      toFlip.forEach(([fx, fy]) => {
        game.board[fy][fx] = player;
      });
    }

    // æ¬¡ã®ã‚¿ãƒ¼ãƒ³
    function nextTurn() {
      game.turn = game.turn === 'black' ? 'white' : 'black';

      // ç½®ã‘ã‚‹å ´æ‰€ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      const validMoves = getValidMoves(game.turn);

      if (validMoves.length === 0) {
        game.passCount++;

        // ä¸¡è€…ã¨ã‚‚ãƒ‘ã‚¹ãªã‚‰çµ‚äº†
        if (game.passCount >= 2 || isBoardFull()) {
          endGame();
        } else {
          setTimeout(() => {
            alert(`${game.turn === 'black' ? 'é»’' : 'ç™½'}ã¯ç½®ãå ´æ‰€ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¹ã—ã¾ã™ã€‚`);
            nextTurn();
          }, 300);
        }
      }

      render();
    }

    // ç›¤é¢ãŒåŸ‹ã¾ã£ãŸã‹ãƒã‚§ãƒƒã‚¯
    function isBoardFull() {
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          if (!game.board[y][x]) return false;
        }
      }
      return true;
    }

    // ã‚²ãƒ¼ãƒ çµ‚äº†
    function endGame() {
      game.gameOver = true;
      const { black, white } = countPieces();

      let message = '';
      if (black > white) {
        message = `ğŸ‰ é»’ã®å‹ã¡ï¼\né»’: ${black} - ç™½: ${white}`;
      } else if (white > black) {
        message = `ğŸ‰ ç™½ã®å‹ã¡ï¼\né»’: ${black} - ç™½: ${white}`;
      } else {
        message = `ğŸ¤ å¼•ãåˆ†ã‘ï¼\né»’: ${black} - ç™½: ${white}`;
      }

      render();
      setTimeout(() => alert(message), 500);
    }

    // çŸ³ã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
    function countPieces() {
      let black = 0, white = 0;

      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          if (game.board[y][x] === 'black') black++;
          if (game.board[y][x] === 'white') white++;
        }
      }

      return { black, white };
    }

    // ã‚¹ã‚³ã‚¢æ›´æ–°
    function updateScore() {
      const { black, white } = countPieces();

      const blackEl = document.getElementById('blackScore');
      const whiteEl = document.getElementById('whiteScore');

      blackEl.querySelector('.score-value').textContent = black;
      whiteEl.querySelector('.score-value').textContent = white;

      blackEl.classList.toggle('active', game.turn === 'black' && !game.gameOver);
      whiteEl.classList.toggle('active', game.turn === 'white' && !game.gameOver);
    }

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
    function updateStatus() {
      const status = document.getElementById('status');

      if (game.gameOver) {
        const { black, white } = countPieces();
        if (black > white) {
          status.textContent = 'ğŸ‰ é»’ã®å‹ã¡ï¼';
        } else if (white > black) {
          status.textContent = 'ğŸ‰ ç™½ã®å‹ã¡ï¼';
        } else {
          status.textContent = 'ğŸ¤ å¼•ãåˆ†ã‘ï¼';
        }
        status.className = 'status game-over';
      } else {
        status.textContent = game.turn === 'black' ? 'âš« é»’ã®ç•ª' : 'âšª ç™½ã®ç•ª';
        status.className = `status ${game.turn === 'white' ? 'white-turn' : ''}`;
      }
    }

    // å±¥æ­´è¿½åŠ 
    function addHistory(x, y) {
      const history = document.getElementById('history');
      const item = document.createElement('div');
      item.className = `history-item ${game.turn}`;

      const move = game.history.length + 1;
      const pos = String.fromCharCode(65 + x) + (y + 1);
      item.textContent = `${move}æ‰‹ç›®: ${game.turn === 'black' ? 'âš«' : 'âšª'} ${pos}`;

      history.appendChild(item);
      history.scrollTop = history.scrollHeight;

      game.history.push({ x, y, player: game.turn });
    }

    // æ–°è¦ã‚²ãƒ¼ãƒ 
    function newGame() {
      if (game.history.length > 0 && !confirm('æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’å§‹ã‚ã¾ã™ã‹ï¼Ÿ')) return;

      init();
      document.getElementById('history').innerHTML = 
        '<p style="text-align: center; color: #94a3b8;">ã‚²ãƒ¼ãƒ ãŒé€²ã‚€ã¨è¡¨ç¤ºã•ã‚Œã¾ã™</p>';
      render();
    }

    // 1æ‰‹æˆ»ã™
    function undoMove() {
      if (game.history.length === 0) {
        alert('æˆ»ã™æ‰‹ãŒã‚ã‚Šã¾ã›ã‚“');
        return;
      }

      // å±¥æ­´ã‹ã‚‰æœ€å¾Œã®æ‰‹ã‚’å–å¾—
      const lastMove = game.history.pop();
      
      // ç›¤é¢ã‚’æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã™
      init();
      const moves = [...game.history];
      game.history = [];

      moves.forEach(move => {
        game.board[move.y][move.x] = move.player;
        flipPieces(move.x, move.y, move.player);
        game.turn = game.turn === 'black' ? 'white' : 'black';
      });

      // å±¥æ­´ã‚’å†æ§‹ç¯‰
      const historyEl = document.getElementById('history');
      historyEl.innerHTML = '';
      moves.forEach((move, i) => {
        const item = document.createElement('div');
        item.className = `history-item ${move.player}`;
        const pos = String.fromCharCode(65 + move.x) + (move.y + 1);
        item.textContent = `${i + 1}æ‰‹ç›®: ${move.player === 'black' ? 'âš«' : 'âšª'} ${pos}`;
        historyEl.appendChild(item);
      });

      game.history = moves;
      render();
    }

    // ãƒ‘ã‚¹
    function pass() {
      if (game.gameOver) return;
      
      const validMoves = getValidMoves(game.turn);
      if (validMoves.length > 0) {
        alert('ç½®ã‘ã‚‹å ´æ‰€ãŒã‚ã‚Šã¾ã™ã€‚ãƒ‘ã‚¹ã§ãã¾ã›ã‚“ã€‚');
        return;
      }

      game.passCount++;
      nextTurn();
    }

    // é–‹å§‹
    init();
    render();
  </script>
</body>
</html>